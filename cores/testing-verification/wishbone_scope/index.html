<head>
<link rel="stylesheet" href="../../style.css" type="text/css">
</head>
<a href="javascript:history.go(-1)" onMouseOver="self.status=document.referrer;return true">Go Back</a>
<p align='right'><a href='https://github.com/fabriziotappero/ip-cores/tree/testing-verification_wishbone_scope'>Source code</a></p>
<body>
<div class="main">
 <div class="mid" id="dm">
  <div class="content" id="dmc">
   <h2>
    Details
   </h2>
   <p>
    Name: wbscope
    <br/>
    Created: Jun 21, 2015
    <br/>
    Updated: Jun 22, 2015
    <br/>
    SVN Updated: Jun 22, 2015
    
    
    
    
    
    
   </p>
   <h2>
    Other project properties
   </h2>
   <p>
    Category:
    
     Testing / Verification
    
    <br/>
    Language:
    
     Verilog
    
    <br/>
    Development status:
    
     Mature
    
    <br/>
    Additional info:
    
     Design done
    
    ,
    
     FPGA proven
    
    ,
    
     Specification done
    
    <br/>
    WishBone Compliant: Yes
    <br/>
    License: GPL
   </p>
   <div id="d_Description">
    <h2>
     
     
     Description
    </h2>
    <p id="p_Description">
     This is a wishbone accessible scope or logic analyzer.  Connect this scope internally to your favorite 32-bits of information from internal to your chip. You can also place into the scope a clock enable line, to control "when" those 32-bits of information will be relevant. Thereafter, on every enabled clock, the scope will record a sample of those 32-bits to it's local memory.  Next, connect a trigger to the scope, just some event that must take place before the data you have placed into the scope is meaningful for you.  The last piece of configuration is the holdoff--once the trigger line goes high for at least one data clock, the scope will continue recording for holdoff samples/counts before stopping.  Once the scope stops recording, it'll issue an interrupt pulse to any interrupt controller you might have in your design and you can then read all of the bits back out and see what was happening internal to your FPGA.
     <br/>
     The entire approach depends upon the existence of a working 32-bit bus and 2 addresses on that bus (one for control, one for data), but after that the core can be exceptionally useful in figuring out what is going on.
     <br/>
     I've used this core to debug PS/2 interactions, Q/SPI flash interactions, Xilinx internal configuration access port interactions, as well as wishbone bus problems. For the PS/2, I set the core up to trigger on the beginning of a PS/2 command and set the holdoff to almost the full length of the buffer. From here, I discovered that I really misunderstood how PS/2 works. (Oops) For another problem, I was struggling with the wishbone bus locking up. By using a separate bus driver, and controlling which driver (serial port or compressed serial port) controlled the bus through a manual user switch, I could recover the wishbone bus.  I then set the scope to trigger off the bus locking up and the holdoff to zero. When the trigger then went off, I could see 2k words of debugging info (the length is configurable) from before the "event" to see what lead up to it.
     <br/>
     Yes, I understand there are proprietary solutions to these problems--many using the JTAG port. This is not that. This is just a simple, pure, Verilog core for debugging and testing.  It has been invaluable to me, here it is shared for others to use.
     <br/>
    </p>
   </div>
  </div>
  <div style="clear:both;margin-left:200px;">
  </div>
 </div>
</div>
</body>
<p id='foot'>Database updated on 22 June 2015</p>
