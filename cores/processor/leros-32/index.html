<head>
<link rel="stylesheet" href="../../style.css" type="text/css">
</head>
<a href="javascript:history.go(-1)" onMouseOver="self.status=document.referrer;return true">Go Back</a>
<p align='right'><a href='No_svn_archive_link_available.tar.gz'>Source code</a></p>
<body>
<div class="main">
 <div class="mid" id="dm">
  <div class="content" id="dmc">
   <h2>
    Details
   </h2>
   <p>
    Name: leros32
    <br/>
    Created: Mar 27, 2013
    <br/>
    Updated: Apr  3, 2013
    <br/>
    SVN:
    <b>
     No files checked in
    </b>
   </p>
   <h2>
    Other project properties
   </h2>
   <p>
    Category:
    
     Processor
    
    <br/>
    Language:
    
     VHDL
    
    <br/>
    Development status:
    
     Alpha
    
    <br/>
    Additional info:
    
     Design done
    
    <br/>
    WishBone Compliant: No
    <br/>
    License: LGPL
   </p>
   <div id="d_Description">
    <h2>
     
     
     Description
    </h2>
    <p id="p_Description">
     Leros-32 is a 32-bit ALU port of the
     
      Leros project
     
     . It contains an icache and dcache implementation and interface for Xilinx based memory controller access. All of this can be realized inside of ~350 logic cells and 2 brams. This processor achieves &gt; 100mhz running frequency inside of Spartan-6 hardware. A simple assembler is currently implemented and a port of binutils and llvm is in the works. 

The processor core itself is an accumulator based design with an additional register for memory accesses. There are 256 pseudo registers which can be loaded or stored from the accumulator without touching the memory subsystem. All instructions except indirect load/store execute in a single cycle. Regular RISC 3 register codes can be emulated on this architecture using 3 operations. For example
     <br/>
     add r0, r1, r2
     <br/>
     could be translated to:
     <br/>
     load r1
     <br/>
     add r2
     <br/>
     store r0
     <br/>
     Such a technique is being explored for the LLVM port. In theory this should give leros about 1/3 the DMIPS/mhz as other much larger 32-bit cpus. However optimizations are often possible. For example the code a = b + c + d + e +f +g could be compiled into nearly the same number of instructions on leros-32 and ARM. Additionally, ARM may have several pipeline stalls to execute that code where as Leros-32 will have zero.
    </p>
   </div>
   <div id="d_Features">
    <h2>
     
     
     Features
    </h2>
    <p id="p_Features">
     <ul>
      <li>
       32-bit ALU
      </li>
      <li>
       4GiB addressable memory
      </li>
      <li>
       Wishbone I/O Port
      </li>
      <li>
       Integral caches
      </li>
      <li>
       Extremely small logic footprint
      </li>
      <li>
       Single cycle execution of micro-ops
      </li>
      <li>
       Unified memory model
      </li>
      <li>
       Delay based simulation coding style
      </li>
      <li>
       High clock speed
      </li>
      <li>
       Assembler included
      </li>
     </ul>
    </p>
   </div>
   <div id="d_Getting Leros-32">
    <h2>
     
     
     Getting Leros-32
    </h2>
    <p id="p_Getting Leros-32">
     Leros-32 source is currently hosted at
     
      github
     
     .
    </p>
   </div>
   <div id="d_Status">
    <h2>
     
     
     Status
    </h2>
    <p id="p_Status">
     <ul>
      <li>
       Runs in simulator with various test programs
      </li>
      <li>
       TODO - port binutils
      </li>
      <li>
       TODO - C compiler to generate more elaborate tests
      </li>
      <li>
       TODO - Some elaborate race conditions are still know to exist in the d-cache but can be avoided by crafted assembler
      </li>
      <li>
       TODO - Hardware verification not yet done
      </li>
     </ul>
    </p>
   </div>
  </div>
  <div style="clear:both;margin-left:200px;">
  </div>
 </div>
</div>
</body>
<p id='foot'>Database updated on 03 June 2015 by freerangefactory.org</p>
